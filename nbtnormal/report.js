/* jshint loopfunc: true */

jQuery(document).ready(function () {
    $("section").hide();
    $("#options").show();
    
    const metrics = {};
    const results = {}; // For parsed measurement data
    let summaryManuallyEdited = false; // Track if user has manually edited the summary

    // Generate measurements table with input boxes for manual entry
    function generateMeasurementsTable() {
        let rows = ``;
        
        for (const section of parseConfig) {
            rows += `<tr><th colspan="2">${section.title}</th></tr>`;
            
            for (const [key, value] of Object.entries(section.params)) {
                const displayValue = results[key] ? results[key] : "";
                const unit = value.unit || '';
                rows += `<tr>
                    <td class="label">${value.label}</td>
                    <td class="measurement-cell">
                        <input type="text" class="measurement-input" data-key="${key}" value="${displayValue}" />
                        ${unit ? `<span class="unit-label">${unit}</span>` : ''}
                    </td>
                </tr>`;
            }
        }
        
        const dataTemplate = Handlebars.compile(`
            <table>
                <tbody>${rows}</tbody>
            </table>
        `);
        
        $("#measurements-table").html(dataTemplate());
        
        // Add event listeners for measurement inputs
        $(".measurement-input").on("change input", function() {
            const key = $(this).data("key");
            const value = $(this).val();
            const unit = $(this).closest('td').find('.unit-label').text();
            
            // Store value with unit appended (no space)
            if (value && unit) {
                results[key] = value + unit;
            } else {
                results[key] = value;
            }
        });
    }
    
    // Generate the measurements table on load
    generateMeasurementsTable();

    function updateSummary() {
        const summaryItems = [];
        
        // Collect all summary items with their order
        for (const section of options) {
            for (const key in section.params) {
                const option = section.params[key];
                if (option.enableSummary) {
                    const checkbox = $(`#${key}-summary`);
                    if (checkbox.length && checkbox.is(':checked')) {
                        // Get the current value from metrics
                        if (metrics[key] && metrics[key].trim()) {
                            summaryItems.push({
                                text: metrics[key],
                                order: option.summaryOrder !== undefined ? option.summaryOrder : 999 // Default to end if no order specified
                            });
                        }
                    }
                }
            }
        }
        
        // Sort by order, then join
        summaryItems.sort((a, b) => a.order - b.order);
        const summaryParts = summaryItems.map(item => item.text);
        
        const summaryTextarea = $('#Summary textarea');
        if (summaryTextarea.length && !summaryTextarea.is(':focus')) {
            const autoGeneratedContent = summaryParts.join('\n');
            
            if (summaryManuallyEdited) {
                // If user has manually edited, preserve their content and append new auto-generated items
                const currentContent = summaryTextarea.val();
                
                // Split current content into lines
                const currentLines = currentContent.split('\n').filter(line => line.trim());
                
                // Split auto-generated into lines
                const autoLines = autoGeneratedContent.split('\n').filter(line => line.trim());
                
                // Find lines in auto-generated that aren't in current content
                const newLines = autoLines.filter(line => !currentLines.includes(line));
                
                // Combine: keep current content and add any new auto-generated lines
                if (newLines.length > 0) {
                    const updatedContent = currentContent + '\n' + newLines.join('\n');
                    summaryTextarea.val(updatedContent);
                    metrics.Summary = updatedContent;
                }
            } else {
                // No manual edits yet, just replace with auto-generated
                summaryTextarea.val(autoGeneratedContent);
                metrics.Summary = autoGeneratedContent;
            }
        }
    }
    
    for (const k in options) {
        $("#options-content").append(`
    <h3>${options[k].title}</h3>
    
`);

        for (const key in options[k].params) {
            const option = options[k].params[key];
            
            // Determine layout class
            let layoutClass = '';
            if (!option.options && option.custom) {
                layoutClass = 'no-dropdown'; // Scenario c: textarea only
            } else if (option.options && !option.custom) {
                layoutClass = 'dropdown-only'; // Scenario a: dropdown only
            } else if (option.options && option.custom && option.conditionalText) {
                layoutClass = 'conditional-textarea'; // Scenario d: dropdown with conditional textarea
            }
            // Default (no class) is scenario b: dropdown + always-visible textarea
            
            const $option = $(`<div id="${key}" class="${layoutClass}">
    <div class="label-container">
        ` + (option.title ? `<label>${option.title}</label>` : '') + `
    </div>
    ` + (option.options ? `
    <div class="dropdown-container">
        <select>
            <option selected disabled value="" >Select...</option>
            ` + option.options.map(opt => {
                const isString = typeof opt === 'string';
                const text = isString ? opt : opt.title;
                const label = isString ? opt : (opt.label || opt.text);
                const isDefault = !isString && opt.default;
                return `<option ${isDefault ? 'selected="selected"' : ''} title="${text}" value="${key}-${label.toLowerCase().replace(/ /g, "-")}">${label}</option>`;
            }).join("") + `
        </select>
    </div>
        ` : '') + `
    ` + (option.custom ? `
    <div class="textarea-container" style="${option.conditionalText ? 'display: none;' : ''}">
        <textarea class="${option.large ? 'large' : ''}"></textarea>
    </div>
    ` : '') + `
    ` + (option.enableSummary ? `
    <div class="summary-checkbox-container">
        <input type="checkbox" id="${key}-summary" ${option.summaryDefault ? 'checked' : ''} />
    </div>
    ` : '') + `
</div>`);

            $("#options-content").append($option);

            $("textarea", $option).on("paste", (e) => {
                let paste = (e.originalEvent.clipboardData || window.clipboardData).getData('text');
                paste = paste.replace(/\n/g, ", ").trim();

                // Insert the modified text into the textarea
                let textarea = e.target;
                let currentText = textarea.value;
                let selectionStart = textarea.selectionStart;
                let selectionEnd = textarea.selectionEnd;

                const newText = currentText.slice(0, selectionStart) + paste + currentText.slice(selectionEnd);

                $(e.currentTarget).val(newText);
                $(e.currentTarget).trigger("change");
                return false;
            });

            const df = option.options ? option.options.find(opt => typeof opt !== 'string' && opt.default) : '';
            if (df) {
                metrics[key] = df.title;
            }
            
            if (!option.options && option.default) {
                metrics[key] = option.default;
                $("textarea", $option).val(option.default);
            }

            // Handle conditional textarea visibility
            if (option.conditionalText && option.options) {
                $("select", $option).on("change", function () {
                    const selectedOption = $(this).find(":selected");
                    const selectedTitle = selectedOption.attr("title");
                    
                    // Show textarea if empty title (free text option) is selected
                    if (selectedTitle === "" || selectedTitle === undefined) {
                        $(".textarea-container", $option).show();
                    } else {
                        $(".textarea-container", $option).hide();
                        $("textarea", $option).val(""); // Clear textarea when hidden
                    }
                });
            }

            $("select, textarea", $option).on("change", function () {
                // Skip this handler for Summary field as it has special handling
                if (key === 'Summary') {
                    return;
                }
                
                // Auto-check summary checkbox if summaryOnChange is enabled and a non-default option is selected
                if (option.summaryOnChange && option.enableSummary && option.options) {
                    const selectedOption = $("select", $option).find(":selected");
                    const isDefaultOption = selectedOption.attr('title') === '' || 
                                          option.options.find(opt => 
                                              typeof opt !== 'string' && 
                                              opt.default && 
                                              opt.title === selectedOption.attr('title')
                                          );
                    
                    const checkbox = $(`#${key}-summary`);
                    if (checkbox.length) {
                        // Check the box if a non-default option is selected
                        // Uncheck if default is re-selected (unless it was manually checked)
                        if (!isDefaultOption) {
                            checkbox.prop('checked', true);
                        }
                    }
                }
                
                const vals = [];

                const selected = $("select", $option).find(":selected").attr("title");
                if (selected) {
                    vals.push(selected);
                }

                if (option.custom) {
                    const ta = $("textarea", $option).val();
                    if (ta) {
                        vals.push(ta);
                    }
                }

                metrics[key] = vals.join(" ");
                updateSummary();
            });

            if (option.enableSummary) {
                $(`#${key}-summary`, $option).on('change', function() {
                    updateSummary();
                });
            }
            
            // Special handling for Summary field to capture manual edits
            if (key === 'Summary') {
                $("textarea", $option).on("input change blur", function() {
                    summaryManuallyEdited = true; // Mark that user has manually edited
                    metrics.Summary = $(this).val();
                });
            }
        }
        
        $("#options-content").append(`<hr />`);
    }
        
    updateSummary();
    
    $("#generate").on("click", function () {
        $("#options").hide();
        $("#output").show();

        $("#back").prop("disabled", false).on("click", function () {
            $("#output").hide();
            $("#options").show();
        });
        
        $("#copy").prop("disabled", false).on("click", function () {
            const text = $("#output textarea").val();
            navigator.clipboard.writeText(text);

            $("#copy").html("Copied!");
            setTimeout(() => {
                $("#copy").html("Copy to clipboard");
            }, 1000);
        });

        const output = {
            ...results,
            ...metrics,
        };

        $("#output textarea").val(outputTemplate(output));
    });
});